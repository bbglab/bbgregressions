def process_mutdensity(mutdensity_file, mutdensity_config,
                    rows_names, cols_names,
                    save_files_dir,
                    missing_values_treatment,
                    metric = "mutdensity"):
    """
    Generates and saves pivoted dataframes of mutation densities,
    with columns as samples and rows as genes. Does the same with
    a two column table for the total of the genes and the total
    of the samples. Creates as many versions as those specified
    in mutdensity_config

    Parameters
    ----------
    mutdensity_file: str
        Path to the mutation densities file generated by MUTDENSITY
        process (deepCSA pipeline)
    mutdensity_config: list
        List containing the specific versions to be created
        regarding region and mutations used
        Allowed values: all, nonproteinaffecting, proteinaffecting,
        snv, alltypes, complex-deletion-insertion-mnv, indel
    rows_names: list
        List of values to be used as the row names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add rows with NA we want to keep for downstream
        analysis. If rows_names=[''], uses all the genes in mutdensity_file_f
    cols_names: list
        List of values to be used as the column names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add columns with NA we want to keep for downstream
        analysis
    save_files_dir: str
        Path where to store the generated files
    metric: str (default: "mutdensity")
        Mutation rate metric to use, which can be mutation density or
        mutated reads rate.
        Allowed values: mutdensity, mutreadsrate

    Returns
    -------
    None
    """

    # load master mutdensity file
    mutdensity_df = pd.read_csv(mutdensity_file, sep = "\t")

    # set table settings
    mutdensity_config_fixed = []
    for val in mutdensity_config:
        vals = val.split("-")
        mutdensity_config_fixed.extend(vals)

    print(mutdensity_config_fixed)

    # set version settings
    ## main metric
    if metric == "mutdensity":
        metric = "MUTDENSITY_MB"
    elif metric == "mutreadsrate":
        metric = "MUTREADSRATE_MB"

    ## region
    regressions2mutdensity_regions = {"all": "all",
                                   "nonproteinaffecting": "non_protein_affecting",
                                   "proteinaffecting": "protein_affecting"}
    regions = []
    for region in regressions2mutdensity_regions:
        if region in mutdensity_config_fixed:
            regions.append(regressions2mutdensity_regions[region])

    ## muts used
    regressions2mutdensity_muts = {"snv": "SNV",
                                "alltypes": "all_types",
                                "complex-deletion-insertion-mnv": "COMPLEX-DELETION-INSERTION-MNV",
                                "indel": "DELETION-INSERTION"}
    muttypes = []
    for muttype in regressions2mutdensity_muts:
        if muttype in mutdensity_config_fixed:
            muttypes.append(regressions2mutdensity_muts[muttype])

    # create tables
    for region in regions:
        for muttype in muttypes:

            mutdensity_df_f = mutdensity_df.loc[(mutdensity_df["REGIONS"] == region)
                                                & (mutdensity_df["MUTTYPES"] == muttype)]
            mutdensity_df_f = mutdensity_df_f.rename({"GENE": "gene", "SAMPLE_ID": "sample"}, axis = 1)

            if rows_names == ['']:
                rows_names = [gene for gene in list(mutdensity_df_f["gene"].unique()) if gene != "ALL_GENES"]

            if muttype == "DELETION-INSERTION": # to correctly name the file below
                muttype = "indel"

            create_metric_table(metric_df = mutdensity_df_f,
                                metric_var = metric,
                                rows_var = "gene", cols_var = "sample",
                                rows_names = rows_names, cols_names = cols_names,
                                total_cols_by = "ALL_GENES",
                                total_rows_by = "all_samples",
                                metric_var4file = f'{metric.split("_")[0]}.{"".join(region.split("_"))}_{muttype.lower().replace("_", "")}',
                                save_files_dir = save_files_dir,
                                keep_rows_ordered = True, keep_cols_ordered = True,
                                missing_values = missing_values_treatment
                                )

    return None

def process_oncodrivefml(oncodrivefml_data, oncodrivefml_config, total_cols_by,
                         rows_names, cols_names,
                         missing_values_treatment,
                         save_files_dir):
    """
    Generates and saves pivoted dataframes of OncodriveFML metrics
    (z-score and difference between observed and expected mean
    deleteriousness scores), with columns as samples and rows as genes.
    Does the same with a two column table for the total of
    the genes and the total of the samples.
    Creates as many versions as those specified in
    oncodrivefml_config

    Parameters
    ----------
    oncodrivefml_data: str
        Path to the directory where the output files of OncodriveFML
        are stored or comma-separated string with paths to each sample's directory
    oncodrivefml_config: list
        List containing the specific versions to be created
        regarding metric, profile and significance level
        Allowed values: zscore, diffobsvsexp, allprof,
        nonprotaffprof, nosignificant, significant
    total_cols_by: str
        How to calculate the total for the columns of the dataframe.
        Can be "sum", "mean" or "median"
    rows_names: list
        List of values to be used as the row names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add rows with NA we want to keep for downstream
        analysis. If rows_names=[''], uses all the genes in oncodrivefml_df_f
    cols_names: list
        List of values to be used as the column names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add columns with NA we want to keep for downstream
        analysis
    save_files_dir: str
        Path where to store the generated files

    Returns
    -------
    None
    """

    # load OncodriveFML results in a df
    oncodrivefml_df = pd.DataFrame()
    oncodrivefml_data = [item.strip() for item in oncodrivefml_data.split(",")]

    ## a single path was provided with all the directories per sample
    if len(oncodrivefml_data) == 1:
        oncodrivefml_dir = oncodrivefml_data[0]
        oncodrivefml_data = [f"{oncodrivefml_dir}/{file}/{file.split('.')[0]}-oncodrivefml.tsv.gz" for file in os.listdir(oncodrivefml_dir)]
        for file in oncodrivefml_data:
            sample_df = pd.read_csv(file, sep = "\t", header = 0)
            sample_df["sample"] = file.split("/")[-2]
            oncodrivefml_df = pd.concat((oncodrivefml_df, sample_df)).reset_index(drop = True)
    ## a list of directory paths was provided
    else:
        for file_dir in oncodrivefml_data:
            sample_df = pd.read_csv(f"{file_dir}/{file_dir.split('.')[0]}-oncodrivefml.tsv.gz", sep = "\t", header = 0)
            sample_df["sample"] = file_dir
            oncodrivefml_df = pd.concat((oncodrivefml_df, sample_df)).reset_index(drop = True)

    # set version settings
    ## main metric
    metrics = []
    if "zscore" in oncodrivefml_config:
        metrics.append("Z-SCORE")
    if "diffobsvsexp" in oncodrivefml_config:
        ### compute difference between expected and observed mean deleteriousness scores
        oncodrivefml_df["DIFF-OBSvsEXP"] = oncodrivefml_df["AVG_SCORE_OBS"] - oncodrivefml_df["POPULATION_MEAN"]
        metrics.append("DIFF-OBSvsEXP")

    ## profile
    profiles = []
    regressions2fml_profile = {"allprof": ".all",
                                "nonprotaffprof": ".non_prot_aff"}
    for prof in regressions2fml_profile:
        if prof in oncodrivefml_config:
            profiles.append(regressions2fml_profile[prof])

    # create tables
    for metric_var in metrics:
        for profile in profiles:

            oncodrivefml_df_f = oncodrivefml_df.loc[oncodrivefml_df["sample"].str.contains(profile)]
            oncodrivefml_df_f["sample"] = oncodrivefml_df_f.apply(
                lambda row: row["sample"].split(".")[0], axis = 1)    # after use, remove profile info to every sample id
            oncodrivefml_df_f = oncodrivefml_df_f.rename({"GENE_ID": "gene"}, axis = 1)
            if rows_names == ['']:
                rows_names = [gene for gene in list(oncodrivefml_df_f["gene"].unique()) if gene != "ALL_GENES"]

            ## table w/ all oncodrivefml values, regardless of significance
            if "nosignificant" in oncodrivefml_config:
                create_metric_table(metric_df = oncodrivefml_df_f,
                                    metric_var = metric_var,
                                    rows_var = "gene", cols_var = "sample",
                                    rows_names = rows_names, cols_names = cols_names,
                                    total_cols_by = total_cols_by,
                                    total_rows_by = "all_samples",
                                    metric_var4file = f'oncodrivefml.{"".join(metric_var.split("-"))}_{"".join(profile[1:].split("_"))}prof_nosignificant',
                                    save_files_dir = save_files_dir,
                                    keep_rows_ordered = True, keep_cols_ordered = True,
                                    missing_values = missing_values_treatment
                                    )

            ## table w/ only significant values
            if "significant" in oncodrivefml_config:
                ### aproach 1: filter out non-significant values, generates NA
                # oncodrivefml_df_f.loc[(oncodrivefml_df_f["Q_VALUE"] > 0.05)
                                    # | ((oncodrivefml_df_f["Q_VALUE"].isna()) & (oncodrivefml_df_f["P_VALUE"] > 0.05)), metric_var] = np.nan                                          | ((oncodrivefml_df_f["Q_VALUE"].isna()) & (oncodrivefml_df_f["P_VALUE"] < 0.05))]
                ### aproach 2: fill non-significant values with zero
                oncodrivefml_df_f.loc[(oncodrivefml_df_f["Q_VALUE"] > 0.05)
                                    | ((oncodrivefml_df_f["Q_VALUE"].isna()) & (oncodrivefml_df_f["P_VALUE"] > 0.05)), metric_var] = 0
                create_metric_table(metric_df = oncodrivefml_df_f,
                                    metric_var = metric_var,
                                    rows_var = "gene", cols_var = "sample",
                                    rows_names = rows_names, cols_names = cols_names,
                                    total_cols_by = total_cols_by,
                                    total_rows_by = "all_samples",
                                    metric_var4file = f'oncodrivefml.{"".join(metric_var.split("-"))}_{"".join(profile[1:].split("_"))}prof_significant',
                                    save_files_dir = save_files_dir,
                                    keep_rows_ordered = True, keep_cols_ordered = True,
                                    missing_values = missing_values_treatment
                                    )

    return None

def process_omega(omega_data, omega_config,
                        total_cols_by,
                        rows_names, cols_names,
                        save_files_dir,
                        missing_values_treatment,
                        omega_modality = "mle",
                        global_loc = True):
    """
    Generates and saves pivoted dataframes of omega (MLE or bayes),
    with columns as samples and rows as genes.
    Does the same with a two column table for the total of
    the genes and the total of the samples.
    Creates as many versions as those specified in
    omega_config

    Parameters
    ----------
    omega_dir: str
        Path to the directory where the output files of omega
        are stored or comma-separated string with file names
    total_cols_by: str
        How to calculate the total for the columns of the dataframe.
        Can be "sum", "mean" or "median"
    rows_names: list
        List of values to be used as the row names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add rows with NA we want to keep for downstream
        analysis. If rows_names=[''], uses all the genes in omega_df_f
    cols_names: list
        List of values to be used as the column names of the
        pivoted dataframe. Used both to subset the df if needed
        and to add columns with NA we want to keep for downstream
        analysis
    save_files_dir: str
        Path where to store the generated files
    omega_modality: str (default: "mle")
        Omega modality used to compute omegas. Can be "mle" or "bayes".

    Returns
    -------
    None
    """

    # load omega results in a df
    omega_df = pd.DataFrame()
    omega_data = [item.strip() for item in omega_data.split(",")]
    if len(omega_data) == 1:
        omega_dir = omega_data[0]
        omega_data = [f"{omega_dir}/{file}" for file in os.listdir(omega_dir) if omega_modality in file]
        for file in omega_data:
            try :
                sample_df = pd.read_csv(file, sep = "\t", header = 0)
            except pd.errors.EmptyDataError:
                sample_df = pd.DataFrame()
            sample_df["sample"] = file.split("/")[-1]
            omega_df = pd.concat((omega_df, sample_df)).reset_index(drop = True)
    else:
        for file in omega_data:
            try :
                sample_df = pd.read_csv(file, sep = "\t", header = 0)
            except pd.errors.EmptyDataError:
                sample_df = pd.DataFrame()
            sample_df["sample"] = file
            omega_df = pd.concat((omega_df, sample_df)).reset_index(drop = True)

    # set table settings
    omega_config_fixed = []
    for val in omega_config:
        vals = val.split("-")
        omega_config_fixed.extend(vals)

    print(omega_config_fixed)
    metric_var = "dnds"

    ## mutation impacts
    regressions2omega_impacts = {"essentialsplice": "essential_splice",
                                "essentialspliceplus": "essential_splice_plus",
                                "missense": "missense",
                                "nonsense": "nonsense",
                                "nonsynonymoussplice": "nonsynonymous_splice",
                                "truncating": "truncating",
                                "truncatingplus": "truncating_plus"}
    impacts = []
    for impact in regressions2omega_impacts:
        if impact in omega_config_fixed:
            impacts.append(regressions2omega_impacts[impact])
    print(impacts)

    ## profile
    regressions2omega_profile = {"allprof": "NoValue",
                                "nonprotaffprof": "non_prot_aff"}
    omega2regressions_profile = {"NoValue": "allprof",
                                "non_prot_aff": "nonprotaffprof"}
    profiles = []
    for prof in regressions2omega_profile:
        if prof in omega_config_fixed:
            profiles.append(regressions2omega_profile[prof])

    ## unique or multi muts
    regressions2omega_muts = {"uniquemuts": "NoValue",
                            "multimuts": "multi"}
    omega2regressions_muts = {"NoValue": "uniquemuts",
                            "multi": "multimuts"}
    uniqueormulti_muts = []
    for muts in regressions2omega_muts:
        if muts in omega_config_fixed:
            uniqueormulti_muts.append(regressions2omega_muts[muts])

    samples = list(set([".".join(file.split(".")[:2]) for file in omega_df["sample"]]))
    for profile in profiles:
        for uniqormulti in uniqueormulti_muts:
            if global_loc:
                analysis_info = [f'{sampl}.{profile}.{uniqormulti}.global_loc.tsv'.replace('.NoValue', '') for sampl in samples]
            else:
                analysis_info = [f'{sampl}.{profile}.{uniqormulti}.tsv'.replace('.NoValue', '') for sampl in samples] # this way we do the subset properly (checked)

            for impact in impacts:
                omega_df_f = omega_df.loc[(omega_df["sample"].isin(analysis_info)) &
                                            (omega_df["impact"] == impact)]
                print(omega_df_f)
                omega_df_f["sample"] = omega_df_f.apply(lambda row: row["sample"].split(".")[1], axis = 1)   # after use, remove analysis info to every sample id
                omega_df_f = omega_df_f.rename({"GENE_ID": "gene"}, axis = 1)
                if rows_names == ['']:
                    rows_names = [gene for gene in list(omega_df_f["gene"].unique()) if gene != "ALL_GENES"]

                ## table w/ all omega values, regardless of significance
                if "nosignificant" in omega_config_fixed:
                    metric_var4file = f"omega.{metric_var}_{omega_modality}_{impact.replace('_', '')}_{omega2regressions_profile[profile]}_{omega2regressions_muts[uniqormulti]}_nosignificant"
                    create_metric_table(metric_df = omega_df_f,
                                        metric_var = metric_var,
                                        rows_var = "gene", cols_var = "sample",
                                        rows_names = rows_names, cols_names = cols_names,
                                        total_cols_by = total_cols_by,
                                        total_rows_by = "all_samples",
                                        metric_var4file = metric_var4file,
                                        save_files_dir = save_files_dir,
                                        keep_rows_ordered = True, keep_cols_ordered = True,
                                        missing_values = missing_values_treatment)

                ## table w/ only significant omega values
                if "significant" in omega_config_fixed:
                    metric_var4file = f"omega.{metric_var}_{omega_modality}_{impact.replace('_', '')}_{omega2regressions_profile[profile]}_{omega2regressions_muts[uniqormulti]}_significant"
                    ### aproach 1: filter out non-significant values, generates NA
                    # omega_df_f = omega_df_f.loc[(omega_df_f["pvalue"] < 0.05)]
                    ### aproach 2: fill non-significant values with zero
                    omega_df_f.loc[(omega_df_f["pvalue"] > 0.05), metric_var] = 0
                    create_metric_table(metric_df = omega_df_f,
                                        metric_var = metric_var,
                                        rows_var = "gene", cols_var = "sample",
                                        rows_names = rows_names, cols_names = cols_names,
                                        total_cols_by = total_cols_by,
                                        total_rows_by = "all_samples",
                                        metric_var4file = metric_var4file,
                                        save_files_dir = save_files_dir,
                                        keep_rows_ordered = True, keep_cols_ordered = True,
                                        missing_values = missing_values_treatment)


    return None